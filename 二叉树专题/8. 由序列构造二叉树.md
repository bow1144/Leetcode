# 由序列构造二叉树

可以由**中序、后序遍历**和**前序、中序遍历**构造二叉树，但是只由前序、后序遍历
无法构建唯一二叉树，也就是说由序列构造二叉树**必须要有中序遍历**

## 从中序与后序遍历序列构造二叉树
由序列构造二叉树的问题本质是基于中序遍历的**分治思想**。确定一个节点为根节点后，在
中序遍历中，**序列左边的点一定在其左子树，右边的点一定在其右子树**

### 思路
* 序列构造
  1. 中序序列：`[left, root, right]`
  2. 后续遍历：`[left, right, root]`
* 分治思想
  1. 对于一组序列，**首先找到其根节点**，利用后序遍历查找根节点
  2. 利用中序遍历将节点分为**左右子树两组节点**
  3. 构建左右子树的中序序列
  4. 由中序序列得出左右子树的大小，从而构建左右子树的后序遍历
 
### 代码
```
class Solution {
public:
    TreeNode* travelsar(vector<int>& inorder, vector<int>& postorder) {
        int size = inorder.size();
        if(!size) return nullptr;
        int root_val = postorder[size-1], root_idx = 0;
        for(root_idx=0; root_idx<size; root_idx++) if(inorder[root_idx] == root_val) break;

        vector<int> left_inorder(inorder.begin(), inorder.begin()+root_idx);
        vector<int> right_inorder(inorder.begin()+root_idx+1, inorder.end());

        vector<int> left_postorder(postorder.begin(), postorder.begin()+root_idx);
        vector<int> right_postorder(postorder.begin()+root_idx, postorder.end()-1);

        TreeNode* root = new TreeNode(root_val);
        root->left = travelsar(left_inorder, left_postorder);
        root->right = travelsar(right_inorder, right_postorder);
        return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return travelsar(inorder, postorder);
    }
};
```

## 从前序与中序遍历序列构造二叉树

### 思路

* 序列构造
  1. 前序序列：`[root, left, right]`
  2. 中序序列：`[left, root, right]`
* 分治思想同上

### 代码
```
class Solution {
public:
    TreeNode* travel(vector<int>& preorder, vector<int>& inorder){
        if(!preorder.size()) return nullptr;
        int root_value = preorder[0], half_idx = 0;
        TreeNode* root = new TreeNode(root_value);

        for(half_idx=0; half_idx<inorder.size(); half_idx++)
            if(inorder[half_idx] == root_value) break;

        vector<int> left_inorder(inorder.begin(), inorder.begin()+half_idx);
        vector<int> right_inorder(inorder.begin()+1+half_idx, inorder.end());
        vector<int> left_preorder(preorder.begin()+1, preorder.begin()+1+left_inorder.size());
        vector<int> right_preorder(preorder.begin()+1+left_inorder.size(), preorder.end());

        root->left = travel(left_preorder, left_inorder);
        root->right = travel(right_preorder, right_inorder);

        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return travel(preorder, inorder);
    }
};
```
