# 二叉树的公共祖先问题

## 二叉树的最近公共祖先

### 思路
主要思路是**将找到的节点向上返回**

### 代码
```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 基本情况：如果当前节点是p或q，直接返回当前节点
        if(root == p || root == q) return root;
        
        // 如果当前节点为空，返回null（说明没有找到）
        if(!root) return nullptr;

        // 递归查找左子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        
        // 递归查找右子树
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        // 如果左子树和右子树都找到非空的节点，说明当前节点是p和q的最近公共祖先
        if(left && right) return root;

        // 如果左子树为空，返回右子树的结果（可能是找到的公共祖先，也可能是空）
        if(!left) return right;

        // 如果右子树为空，返回左子树的结果
        return left;
    }
};

```

## 二叉搜索树的最近公共祖先

### 思路一、递归

```
class Solution {
public:
    TreeNode* ans;
    void dfs(TreeNode* root, TreeNode* p, TreeNode* q){
        if(!root) return;
        if(root->val >= p->val && root->val <= q->val) {
            ans = root;
            return;
        }
        dfs(root->left, p, q);
        dfs(root->right, p ,q);
        return;
    } 
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(p->val > q->val) swap(p, q);
        dfs(root, p, q);
        return ans;
    }
};
```
