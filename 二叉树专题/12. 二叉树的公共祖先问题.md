# 二叉树的公共祖先问题

## 二叉树的最近公共祖先

### 思路
主要思路是**将找到的节点向上返回**

### 代码
```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 基本情况：如果当前节点是p或q，直接返回当前节点
        if(root == p || root == q) return root;
        
        // 如果当前节点为空，返回null（说明没有找到）
        if(!root) return nullptr;

        // 递归查找左子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        
        // 递归查找右子树
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        // 如果左子树和右子树都找到非空的节点，说明当前节点是p和q的最近公共祖先
        if(left && right) return root;

        // 如果左子树为空，返回右子树的结果（可能是找到的公共祖先，也可能是空）
        if(!left) return right;

        // 如果右子树为空，返回左子树的结果
        return left;
    }
};

```

## 二叉搜索树的最近公共祖先

### 思路一、递归

* 第一次遇到`root->val >= p->val && root->val <= q->val`的节点就是根节点

```
class Solution {
public:
    TreeNode* ans;
    void dfs(TreeNode* root, TreeNode* p, TreeNode* q){
        if(!root) return;
        if(root->val >= p->val && root->val <= q->val) {
            ans = root;
            return;
        }
        dfs(root->left, p, q);
        dfs(root->right, p ,q);
        return;
    } 
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(p->val > q->val) swap(p, q);
        dfs(root, p, q);
        return ans;
    }
};
```

### 思路二、迭代

```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (p->val > q->val) swap(p, q); // 确保 p 的值小于或等于 q 的值
        
        while (root) {
            if (root->val < p->val) {
                // 当前节点值小于p和q的值，说明公共祖先在右子树
                root = root->right;
            } else if (root->val > q->val) {
                // 当前节点值大于p和q的值，说明公共祖先在左子树
                root = root->left;
            } else {
                // 当前节点值位于p和q之间，说明找到了最近公共祖先
                return root;
            }
        }
        return nullptr; // 如果没有找到，返回nullptr（应该不会发生这种情况）
    }
};
```
