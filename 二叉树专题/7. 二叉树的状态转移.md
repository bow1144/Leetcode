# 二叉树的状态转移

二叉树的状态转移是基于二叉树的DFS搜索的一种**剪枝策略**；当一个节点的状态依赖于子节点时，应考虑用`-1`等特殊量，或者用几个`int`类型的数代表状态

## 平衡二叉树

### 思路
* 状态转移：每个节点在递归完之后返回**以该节点为根节点的树的高度**
* 剪枝策略：当该子树不满足平衡树的要求时，返回`-1`

### 代码
```
class Solution {
public:
    int getHeigth(TreeNode* root) {
        if(!root) return 0;
        int left_heigth = getHeigth(root->left);
        int right_heigth = getHeigth(root->right);
        if(left_heigth == -1 || right_heigth == -1) return -1;
        if(abs(left_heigth-right_heigth)>1) return -1;
        return max(left_heigth, right_heigth) + 1;
    }

    bool isBalanced(TreeNode* root) {
        if(getHeigth(root) == -1) return false;
        return true;
    }
};
```

## 监控二叉树
[968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

### 思路
* 贪心
  1. 子节点**一定不放灯**，因为子节点放灯会浪费一层照明
  2. 头节点可以放灯，因为头节点放灯只浪费一个照明
* 遍历
  1. 从叶子节点开始放灯，所以采用**后序遍历**
* 状态转移
一个节点只有：灯、被下层灯照明、不被下层灯照明三种状态：
  1. 当左右子节点**至少一个不被照明**时，该节点必须是灯
  2. 排除状况1后，当左右子节点**至少一个是灯**时，该节点被照明
  3. 排除状态1，2后，当左右子节点**都被下层灯照明时**，该节点不被下层照明
* 起点和终点
  1. 叶子节点**不被下层照明**
  2. 在遍历结束后，如果头节点不被照明，灯的个数加一
 
### 代码
```
class Solution {
    // 0:无覆盖 1:摄像头 2:有覆盖
public:
    int ans = 0;
    int dfs(TreeNode* root) {
        if(!root) return 2;
        int l = dfs(root->left);
        int r = dfs(root->right);
        if(l==0 || r==0) {ans++; return 1;}
        if(l==1 || r==1) return 2;
        if(l==2 && r==2) return 0;
        return -1;
    }

    int minCameraCover(TreeNode* root) {
        if(dfs(root) == 0) ans++;
        return ans;
    }
};
```
