# 二叉搜索树的属性

## BST的属性
* 没有重复的节点
* 节点具有有序性
* 子树也是二叉搜索树
* **在中序遍历下，二叉搜索树的序列有序**

## 二叉搜索树中的搜索

### 思路
* 递归三部曲
  1. 传入参数：节点，要找的值
  2. 结束条件：找到了、没有该值
  3. 层内逻辑：先确认是否找到、有没有可能找到，再在左右节点中找
 
### 代码
```
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;
        if(val == root->val) return root;
        if(val < root->val) return searchBST(root->left, val);
        else return searchBST(root->right, val);
        return nullptr;
    }
};
```

## 验证二叉搜索树

### 思路
中序遍历，检查遍历序列是否有序

### 代码
```
class Solution {
public:
    vector<int> inorder;
    void dfs(TreeNode* root) {
        if(!root) return;
        dfs(root->left);
        inorder.push_back(root->val);
        dfs(root->right);
        return;
    }

    bool isValidBST(TreeNode* root) {
        dfs(root);
        for(int i=0; i<inorder.size()-1; i++)
            if(inorder[i+1] <= inorder[i]) return false;
        return true;
    }
};
```

### 扩展
本题也可以用递归解，但是注意，二叉搜索树的要求是左子树的**全部节点**小于根节点，故需要传参的时候传入区间参数
```
class Solution {
public:
    bool judge(TreeNode* node, long long min_val, long long max_val){
        if(!node) return true;
        long long val = (long long) node->val;
        if(val >= max_val || val <= min_val) return false;
        if(judge(node->left, min_val, val) &&
           judge(node->right, val, max_val))
           return true;
        return false;
    }

    bool isValidBST(TreeNode* root) {
        return judge(root, -1e10, 1e10);
    }
};
```
