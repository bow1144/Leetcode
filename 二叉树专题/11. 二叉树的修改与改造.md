# 二叉树的修改与改造

## 二叉搜索树中的插入操作

### 思路一、BST的区间暴搜
* 传递参数时，传递当前节点子节点的最小最大合法区间
* 对每个节点：如果符合区间，分类讨论是否插入、如何插入
* 如果无法插入，下一次递归并进一步压缩合法区间

```
class Solution {
public:
    void dfs(TreeNode* node, int min_val, int max_val, int val){
        if(min_val<val && max_val>val){
            if(node->left && node->right){
                dfs(node->left, min_val, node->val, val);
                dfs(node->right, node->val, max_val, val);
                return;
            }
            if(!node->left && !node->right){
                TreeNode* n = new TreeNode(val);
                if(val < node->val) node->left = n;
                else node->right = n;
                return;
            }
            else if(!node->left){
                if(node->val > val){
                    TreeNode* n = new TreeNode(val);
                    node->left = n;
                }
                else  dfs(node->right, node->val, max_val, val);
            }
            else if(!node->right){
                if(node->val < val){
                    TreeNode* n = new TreeNode(val);
                    node->right = n;
                }
                else dfs(node->left, min_val, node->val, val);
            }
            return;
        }
        if(node->left) dfs(node->left, min_val, node->val, val);
        if(node->right) dfs(node->right, node->val, max_val, val);
        return;
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            TreeNode* root = new TreeNode(val);
            return root;
        }
        dfs(root, -INT_MAX, INT_MAX, val);
        return root;
    }
};
```

### 思路二：父母节点
* **父母节点可以通过定义全局变量传递**

```
class Solution {
public:
    TreeNode* parent;

    void dfs(TreeNode* node, int val) {
        if(!node) {
            TreeNode* node = new TreeNode(val);
            if (val < parent->val) parent->left = node;
            else parent->right = node;
            return;
        }
        parent = node;
        if(val < node->val) dfs(node->left, val);
        else dfs(node->right, val);
        return;
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        dfs(root, val);
        return root;
    }
};
```
