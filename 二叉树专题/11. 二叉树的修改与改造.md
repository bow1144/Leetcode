# 二叉树的修改与改造

## 二叉搜索树中的插入操作

### 思路一、BST的区间暴搜
* 传递参数时，传递当前节点子节点的最小最大合法区间
* 对每个节点：如果符合区间，分类讨论是否插入、如何插入
* 如果无法插入，下一次递归并进一步压缩合法区间

```
class Solution {
public:
    void dfs(TreeNode* node, int min_val, int max_val, int val){
        if(min_val<val && max_val>val){
            if(node->left && node->right){
                dfs(node->left, min_val, node->val, val);
                dfs(node->right, node->val, max_val, val);
                return;
            }
            if(!node->left && !node->right){
                TreeNode* n = new TreeNode(val);
                if(val < node->val) node->left = n;
                else node->right = n;
                return;
            }
            else if(!node->left){
                if(node->val > val){
                    TreeNode* n = new TreeNode(val);
                    node->left = n;
                }
                else  dfs(node->right, node->val, max_val, val);
            }
            else if(!node->right){
                if(node->val < val){
                    TreeNode* n = new TreeNode(val);
                    node->right = n;
                }
                else dfs(node->left, min_val, node->val, val);
            }
            return;
        }
        if(node->left) dfs(node->left, min_val, node->val, val);
        if(node->right) dfs(node->right, node->val, max_val, val);
        return;
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            TreeNode* root = new TreeNode(val);
            return root;
        }
        dfs(root, -INT_MAX, INT_MAX, val);
        return root;
    }
};
```

### 思路二：父母节点
* **父母节点可以通过定义全局变量传递**

```
class Solution {
public:
    TreeNode* parent;

    void dfs(TreeNode* node, int val) {
        if(!node) {
            TreeNode* node = new TreeNode(val);
            if (val < parent->val) parent->left = node;
            else parent->right = node;
            return;
        }
        parent = node;
        if(val < node->val) dfs(node->left, val);
        else dfs(node->right, val);
        return;
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        dfs(root, val);
        return root;
    }
};
```

## 删除二叉搜索树中的节点

### 思路
* 需要重建一整棵树，所以返回`TreeNode`
* 在遇到应该删除的节点时
  1. 如果节点是叶子节点，直接返回`null`
  2. 如果节点左右子树有一个为空，返回另一个子树
  3. 如果左右都有节点，**将左右子树合并**，合并方法为**将左子树插入到右子树的最小值左边**
 
### 代码
```
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root) return nullptr;
        if(root->val == key){
            if(!root->left && !root->right) return nullptr;
            else if(!root->left) return root->right;
            else if(!root->right) return root->left;
            else{
                TreeNode* curr = root->right;
                while(curr->left) curr = curr->left;
                curr->left = root->left;
                return root->right;
            }
        }
        else{
            if(key < root->val) root->left = deleteNode(root->left, key);
            if(key > root->val) root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```
