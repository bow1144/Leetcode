# 二叉树的修改

## 翻转二叉树

### 思路
使用DFS遍历，节点不为空则翻转左右子节点

### 代码
```
class Solution {
public:
    void dfs(TreeNode* node){
        if(!node) return;
        swap(node->left, node->right);
        dfs(node->left);
        dfs(node->right);
        return;
    }

    TreeNode* invertTree(TreeNode* root) {
        dfs(root);
        return root;
    }
};
```

## 合并二叉树

### 思路
本题的坑点在于遇到叶子节点**不能返回**， 因为另一棵树的叶子节点可能会有子节点

* 递归三部曲
  1. 本题要求重新构造二叉树，所以返回值是`TreeNode*`，传入参数是两个树的节点
  2. 递归的终止条件：**两个节点至少一个为空，直接返回另一棵树**
  3. 在单层递归中构建节点，指认节点的左右子树
 
### 代码
```
class Solution {
public:
    TreeNode* dfs(TreeNode* a, TreeNode* b){
        if(!a) return b;
        if(!b) return a;

        int root_value = a->val + b->val;
        TreeNode* root = new TreeNode(root_value);
        root->left = dfs(a->left, b->left);
        root->right = dfs(a->right, b->right);
        return root;
    }

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        return dfs(root1, root2);
    }
};
```
